// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "Includes/Noise.compute"
#include "Includes/Density.compute"

AppendStructuredBuffer<float> test;
StructuredBuffer<float3> offsets;
float3 noiseOffset;
int octaves;
float lacunarity;
float persistence;
float noiseScale;

float3 centre;
int voxelSize;
float spacing;
float3 offset;
float worldHeightLimit;

float invLerp(float from, float to, float value)
{
    return (value - from) / (to - from);
}

[numthreads(8, 8, 8)]
void CSMain (int3 id : SV_DispatchThreadID)
{
    
    if (id.x >= numPointsPerAxis.x || id.y >= numPointsPerAxis.y || id.z >= numPointsPerAxis.z)
    {
        return;
    }

    float3 pos = centre + id * spacing - offset;
    float3 noisePos = pos / noiseScale + noiseOffset;
    
    float noise = 0;
    
    
    //Sebastian Lague's method of Noise
    /*
    float offsetNoise = 0;

    float frequency = noiseScale / 100;
    float amplitude = 1;
    float weight = 1;
    for (int i = 0; i < octaves; i++)
    {
        float n = SimplexNoise3D((pos + offsetNoise) * frequency + offsets[i] + offset);
        float v = 1 - abs(n);
        v = v * v;
        v *= weight;
        //weight = max(min(v * weightMultiplier, 1), 0);
        noise += v * amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    */
    
    //Maham Pandey's method of noise
    
    float3 xyPos = float3(noisePos.x, 0, noisePos.z);
    
    //Create Rolling hills by checking if y < horizontal perlin
    //noise = -noisePos.y + SimplexNoise3D(p);
    
    
    float hH = SimplexNoise3D(xyPos / 10);
    for (int j = 2; j < octaves; j++)
    {
        hH += SimplexNoise3D(xyPos / (j * 5)) * j / octaves;
    }
    
    //Add different iterations woth different scales of hills
    //noise = -noisePos.y + hH * worldHeightLimit;
    
    
    float pH = SimplexNoise3D(noisePos / 10);
    for (int k = 2; k < octaves; k++)
    {
        pH -= SimplexNoise3D(noisePos / k) * k / octaves;
    }
    
    //Readd 3D noise but it' only 1/4 the strength of horizontal height
    //Still has rolling hills but now has overhangs and caves
    //noise = -noisePos.y + (pH / 4 + hH) * worldHeightLimit;
    
    float3 maskPos = float3(noisePos.x + 4345.35, 0, noisePos.z + -325.2);
    float mm = SimplexNoise3D(maskPos / 50);
    
    //Add a mask to create areas with flatness and areas with hills
    //noise = -noisePos.y + (pH / 2 + hH) * worldHeightLimit * mm;
    
    float3 cP = float3(noisePos.x / 2 - 523.432, noisePos.y - 2.827, noisePos.z + 5516.233);
    float cave = SimplexNoise3D(cP / 5);
    
    for (int l = 2; l < octaves; l++)
    {
        cave += SimplexNoise3D(cP / (l * 2)) * l / octaves;
    }
    
    if (abs(floor(cave * 50)) - 30 > 0)
    {
        cave = abs(cave * 10);
    }
    else
    {
        cave *= 0;
    }
    
    //Add caves
    noise = -noisePos.y + (pH / 2 + hH) * worldHeightLimit * mm - cave * abs(mm);
    
    //TODO: put all these in 1 loop
    
    

    int index = indexFromCoord(id.x, id.y, id.z);
    
    densityValues[index] = float4(pos, noise);
    
}
